// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;

public class PlayerAI : MonoBehaviour
{
	PATileTerrain terrain;

	public PlayerAI() {
		speed = 2.0f;
		health = 100;
		numberOfUpgrades = 0;
	}

	public float points { get; set; }
	public float health { get; set; }
	public int numberOfUpgrades { get; set; }
	public float speed { get; set; }
	public float strength { get; set; }
	public float plantDistance { get; set; }
	public float maxHealth { get; set; }

	public Vector3 moveDirection;
	float timeToChangeMoveDirection;
	float timeBetweenAttacks = 1.0f;
	float attackInitialIntercal = 1.0f;

	float attackDistance = 1;
	
	float changeInterval = 5.0f;
	
	// Use this for initialization
	void Start () {
		moveDirection = this.randomMoveDirection ();

		GameObject go = GameObject.Find("Tile Map");
		if (go != null) terrain = go.GetComponent<PATileTerrain>();
		plantDistance = 10;
		strength = 1;
		maxHealth = 100;
	}
	
	// Update is called once per frame
	void Update () {
		this.updateHealth();
		this.movePlayer();
	}

	void updateHealth() {
		health -= numberOfUpgrades * Time.deltaTime;
		if (health <= 0) {
			this.SendMessage ("playerDead");
			return;
		}
	}
	
	void movePlayer() {
		transform.localPosition += moveDirection * Time.deltaTime * this.speed;
		timeToChangeMoveDirection -= Time.deltaTime;
		if (terrain == null) {
			GameObject go = GameObject.Find("Tile Map");
			if (go != null) terrain = go.GetComponent<PATileTerrain>();
		}

		GameObject nearestPlant = this.nearestPlantPosition();
		Vector3 nearestPlantDirection = new Vector3();
		if (nearestPlant != null) {
			nearestPlantDirection = nearestPlant.transform.localPosition - transform.localPosition;
		}

		float distanceToPlant = nearestPlantDirection.sqrMagnitude;
		if (nearestPlant != null && distanceToPlant < plantDistance * plantDistance) {
			timeToChangeMoveDirection = changeInterval;
			moveDirection = nearestPlantDirection.normalized;

			timeBetweenAttacks -= Time.deltaTime;
			if (distanceToPlant < attackDistance && timeBetweenAttacks <= 0) {
				timeBetweenAttacks = attackInitialIntercal;
				nearestPlant.SendMessageUpwards("Attack", this.gameObject);
			}
		} else if (timeToChangeMoveDirection <= 0) {
			changeMoveDirection();
		} else if (transform.localPosition.x <= 0 || transform.localPosition.x >= terrain.width ||
		           transform.localPosition.z <= 0 || transform.localPosition.z >= terrain.height) {
			print ("out of bounds");
			moveDirection *= -1;
			timeToChangeMoveDirection = changeInterval;
		}

	}

	GameObject nearestPlantPosition() {
		GameObject[] gos = GameObject.FindGameObjectsWithTag("PlantBehaviour");
		GameObject nearestPlant = null;
		bool shouldGoToNearestPlant = false;
		foreach (GameObject go in gos) {
			if (nearestPlant == null) {
				nearestPlant = go;
				Vector3 oldDistance = nearestPlant.transform.localPosition - transform.localPosition;
				if (oldDistance.sqrMagnitude < plantDistance * plantDistance) {
					shouldGoToNearestPlant = true;
				}
			} else {
				Vector3 oldDistance = nearestPlant.transform.localPosition - transform.localPosition;
				Vector3 newDistance = go.transform.localPosition - transform.localPosition;
				if (newDistance.sqrMagnitude < oldDistance.sqrMagnitude) {
					nearestPlant = go;
					if (newDistance.sqrMagnitude < plantDistance * plantDistance) {
						shouldGoToNearestPlant = true;
					}
				}
			}
		}
		return nearestPlant;
	}

	void changeMoveDirection() {
		timeToChangeMoveDirection = changeInterval;
		moveDirection = this.randomMoveDirection ();
	}
	
	Vector3 randomMoveDirection() {
		float velocityX = Random.Range(-1000, 1000);
		float velocityZ = Random.Range(-1000, 1000);
		return new Vector3(velocityX, 0, velocityZ).normalized;
	}
	
	void playerDead() {
		Application.LoadLevel ("game over");
	}

	void killed(GameObject go) {
		if (go.tag.Equals ("PlantBehaviour")) {
			this.points += PlantBehaviour.Points;
			this.health += PlantBehaviour.Food;
			this.health = Mathf.Min(this.health, this.maxHealth);
		} else if (go.tag.Equals ("MeatBehaviour")) {

		}
	}
}


